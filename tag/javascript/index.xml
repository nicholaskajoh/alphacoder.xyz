<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Alpha Coder</title>
    <link>https://alphacoder.xyz/tag/javascript/</link>
    <description>Recent content in JavaScript on Alpha Coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright 2017 to ∞. Nicholas Kajoh. All rights reserved.</copyright>
    <lastBuildDate>Mon, 25 May 2020 23:33:11 +0000</lastBuildDate><atom:link href="https://alphacoder.xyz/tag/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>node_modules: The Node.js black hole</title>
      <link>https://alphacoder.xyz/node-modules/</link>
      <pubDate>Mon, 25 May 2020 23:33:11 +0000</pubDate>
      
      <guid>https://alphacoder.xyz/node-modules/</guid>
      <description>As a Node.js developer, you know just how large (in terms of number of files and directory size) node_modules can be (you&amp;rsquo;ve probably aready seen the memes). But have you ever asked WHY? I hadn&amp;rsquo;t, up until recently, after which I did some goofing around on the interwebs out of curiosity.
Turns out it has to do with 2 things:
How npm (the Node package manager) resolves dependencies. How the Node.</description>
    </item>
    
    <item>
      <title>Fixing UnhandledPromiseRejectionWarning in Node.js</title>
      <link>https://alphacoder.xyz/nodejs-unhandled-promise-rejection-warning/</link>
      <pubDate>Mon, 04 Mar 2019 13:54:48 +0100</pubDate>
      
      <guid>https://alphacoder.xyz/nodejs-unhandled-promise-rejection-warning/</guid>
      <description>JavaScript exhibits asynchronous behaviour for operations that are not completed immediately e.g a HTTP request or timer. These operations accept callbacks — functions which are executed when an operation has been completed.
setTimeout(function() { console.log(&amp;#39;Slow and steady wins the race.&amp;#39;); }, 5000); console.log(&amp;#39;The last shall be the first!&amp;#39;); If you&amp;rsquo;ve written JavaScript for a while, you&amp;rsquo;re probably familiar with callback hell. Callbacks can easily make code unreadable and difficult to reason about.</description>
    </item>
    
    <item>
      <title>Deploy your React-Django app on Heroku</title>
      <link>https://alphacoder.xyz/deploy-react-django-app-on-heroku/</link>
      <pubDate>Tue, 30 Jan 2018 11:52:00 +0000</pubDate>
      
      <guid>https://alphacoder.xyz/deploy-react-django-app-on-heroku/</guid>
      <description>This is a follow up to my post on setting up a React-Django web app. You can take a quick glance if you’ve not seen it yet.
TL;DR: The setup is deployed at http://react-django.herokuapp.com (nothing much there actually) and the code at https://github.com/nicholaskajoh/React-Django.
We’re going to be deploying the app we setup in the previous post on Heroku. Heroku is a popular cloud hosting platform (PaaS) and offers a generous free tier which we’ll be using.</description>
    </item>
    
    <item>
      <title>Here’s a dead simple React-Django setup for your next project</title>
      <link>https://alphacoder.xyz/dead-simple-react-django-setup/</link>
      <pubDate>Thu, 11 Jan 2018 14:39:00 +0000</pubDate>
      
      <guid>https://alphacoder.xyz/dead-simple-react-django-setup/</guid>
      <description>There are several reasons why you might not want to have separate code bases for the front and back end of your app. For one, the project becomes more portable since it can live in one repository/folder. Then again, everything can be deployed on just one server.
TL;DR: https://github.com/nicholaskajoh/React-Django.
Here’s a simple setup for creating a React-Django project. With just a few tweaks, you can swap out React for Angular or Vue.</description>
    </item>
    
    <item>
      <title>Server-side form validation from A to Z with Sails.js</title>
      <link>https://alphacoder.xyz/sailsjs-form-validation/</link>
      <pubDate>Fri, 26 May 2017 23:06:50 +0100</pubDate>
      
      <guid>https://alphacoder.xyz/sailsjs-form-validation/</guid>
      <description>NB: This tutorial is meant for version 0.12 of Sails.js. Version 1 introduced many breaking changes, including a rewrite of the error handling mechanism, so the code in this tutorial will not work with it.
TL;DR: https://github.com/nicholaskajoh/sails-form-validation.
Data validation is a very essential part of any API/web app. Client-side validation is meant to guide a user &amp;ldquo;in real-time&amp;rdquo; as they try to feed your backend with much needed data, but that&amp;rsquo;s not enough.</description>
    </item>
    
    <item>
      <title>Lazy load your content with Django and jQuery</title>
      <link>https://alphacoder.xyz/lazy-loading-with-django-and-jquery/</link>
      <pubDate>Sun, 26 Feb 2017 05:43:00 +0000</pubDate>
      
      <guid>https://alphacoder.xyz/lazy-loading-with-django-and-jquery/</guid>
      <description>Outlined in this tutorial is a simple way to lazy load content using Django’s built-in pagination and the jQuery library. The code samples shown below are for paginating posts in a blog application.
Templates Create 2 templates, index.html and posts.html.
index.html
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; // A CSRF token is required when making post requests in Django // To be used for making AJAX requests in script.js window.CSRF_TOKEN = &amp;#34;{{ csrf_token }}&amp;#34;; &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;My Blog Posts&amp;lt;/h2&amp;gt; &amp;lt;div id=&amp;#34;posts&amp;#34;&amp;gt;{% include &amp;#39;myapp/posts.</description>
    </item>
    
  </channel>
</rss>
